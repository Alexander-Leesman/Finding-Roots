# -*- coding: utf-8 -*-
"""FindRoots.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aFzRfFgQvnfGXJCIZ7hY66oihulLvARi
"""

import math
import numpy as np
import matplotlib.pyplot as plt

#User defined function.
def f(x):
  function = (x**3)-(7*x**2)+(14*x)-3    #Enter a function in place of the one here.
  return function

#Derivation of the user defined function.
def df(x):
  derivative = (3*x**2)-(14*x)+14        #Enter the derivative of the funtion above.
  return derivative

#Bisection Method
#Input guesses of x values a and b as bia and bib and the convergence criterion epsilon.
#Form (a,b,epsilon) or (b,a,epsilon).
#Output x value of root a<=x<=b and number of iterations count.
#Form (x,count).
#Will stop if it loops bimax times without finding a root.
def bisection(bia,bib,biepsilon):
  bic = 0
  biep = biepsilon
  bicount = 0
  bimax = 100              #Number of times looped without finding a root
  #Determines if f(a) is within epsilon to 0.
  while(abs(f(bia)) > biep and bicount < bimax):
    #Determines if a or b is one of the roots.
    #f(a) * f(b) is 0.
    if(f(bib)*f(bia)==0):
      if(f(bia)==0):
        bia = bia
      else:
        bia = bib
    #Determines if there is a root between a and b.
    #f(a) * f(b) is negative
    elif(f(bia)*f(bib)<0):
      bicount += 1    #adds 1 to the count
      if bicount == bimax:
        return "No roots; discontinuity.", bicount
      #Bisects the interval by finding the midpoint.
      bic = (bia+bib)/2
      #Determines if there is a root between a and the midpoint or the midpoint and b, then creates a new interval accordingly.
      if(f(bia)*f(bic)<0):
       bib = bic
      else:
       bia = bic
    #If there are no roots between a and b.
    #f(a) * f(b) is positive.
    else:
      return "No roots between guesses.", bicount
  #Returns root and number of times looped to find the root.
  return bia, bicount

#Newton-Raphson Method
#Input initial guess of x value nra and convergence criterion epsilon.
#Form (nra, epsilon)
#Output x value of root and number of iterations.
#Form (root, number of iterations)
#If there is more than one root in the graph, then the root that returns is the one nearest to the guess.
'''
Runs into issues if f'(nra) = 0:
  If the root is 0, the returned value will not be exactly 0 unless the guess was 0.
  If the root is not 0 and the guess is 0, it will return an error.
'''
def NewRaph(nra,nrepsilon):
  nrcount = 0
  # nrb = nra - (f(nra)/f'(nra)) function repeats until f(nra) >= epsilon
  while(abs(f(nra)) >= nrepsilon):
    nrcount += 1
    nrb = nra - (f(nra)/df(nra))
    nra = nrb
  return nra, nrcount